package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal 
    PROGRAM,
    BREAK,
	CLASS,
	ELSE,
	CONST,
	IF,
	SWITCH,
	DO,
	WHILE,
	NEW,
	PRINT,
	READ,
	RETURN,
	VOID,
	EXTENDS,
	CONTINUE,
    CASE
;

terminal
    PLUS,
	MINUS,
	MULTIPLY,
	DIVIDE,
	MODULO,
	EQUALS,
	PPLUS,
    MMINUS
;

terminal
 	CEQUALS,
	CNEQUALS,
	GREATER,
	GEQUALS,
	LESS,
    LEQUALS
;

terminal
    AND,
    OR
;

terminal
    SEMICOLON,
    COLON,
    COMMA,
    DOT,
    LPAREN,
    RPAREN,
    LBRACE,
    RBRACE,
    LBRACKET,
    RBRACKET,
    QUESTION
;

terminal Integer NUMBER ;

terminal String IDENT ;

nonterminal MethodDeclList MethodDeclList;
nonterminal VarDecl VarDecl;
nonterminal FormalParamList FormalParamList;
nonterminal FormalParamDecl FormalParamDecl;
nonterminal FormPars FormPars;
nonterminal ActualPars ActualPars;
nonterminal ActualParamList ActualParamList;
nonterminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal Addop Addop;
nonterminal Unmatched Unmatched;
nonterminal Matched Matched;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName, Designator, MethodDecl, MethodTypeName;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Expr, Factor, VarDeclList;

Program ::= (Program) PROG IDENT ProgDeclList LBRACE MethodDeclList RBRACE ;

ProgDeclList ::= (DeclList) ProgDeclList ConstDecl
        | (DeclList) ProgDeclList VarDecl
        | (DeclList) ProgDeclList ClassDecl
        | (NoDecl)
;

ProgName ::= (ProgName) IDENT ;

ConstDeclList ::= (ConstDeclList) ConstDeclList ConstDecl
                | (NoConst

ConstDecl ::= (ConstDecl) CONST Type IDENT EQUALS (NUMBER | CHAR | BOOL) {

VarDecl ::= (VarDecl) Type IDENT [LBRACKET RBRACKET] {COMMA IDENT [LBRACKET RBRACKET]} SEMICOLON

ClassDecl ::= (ClassDecl) CLASS IDENT [EXTENDS Type] LBRACE {VarDecl} RBRACE [LBRACE MethodDecl RBRACE] RPAREN ;

MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
                | (NoMethodDeclarations)
;

MethodDecl ::= (MethodDecl) MethodTypeName LPAREN [FormPars] RPAREN {VarDecl} LBRACE Statement RBRACE ;

MethodTypeName ::= (MethodTypeName) Type IDENT
            | (MethodTypeName) VOID IDENT
;

FormPars ::= (FormalParametersDecl) FormPars COMMA FormPar
        | (FormalParameterDecl) FormPar
;

FormPar ::= (FormalParam) Type IDENT
            | (ArrayFormalParam) Type IDENT LBRACKET RBRACKET
;

Type ::= (Type) IDENT ;

StatementList ::= (Statements) LPAREN StatementList Statement RPAREN
            | (NoStatements)
;

Statement ::= (MatchedStatement) MatchedStatement
            | (OpenStatement) OpenStatement
;

MatchedStatement ::= (Assignment) DesignatorStatement SEMICOLON
            | (MatchedStatement) IF LPAREN Condition RPAREN MatchedStatement ELSE MatchedStatement
            | () DO Statement WHILE LPAREN Condition RPAREN SEMICOLON
            // | () SWITCH LPAREN Expr RPAREN LBRACE { CASE NUMBER COLON Statement } RBRACE
            | (BreakStatement) BREAK SEMICOLON
            | (ContinueStatement) CONTINUE SEMICOLON
            | (ReturnExpr) RETURN Expr SEMICOLON
            | (ReturnNoExpr) RETURN SEMICOLON
            | (ReadStatement) READ LPAREN Designator RPAREN SEMICOLON
            // | (PrintStatement) PRINT LPAREN Expr [COMMA NUMBER] RPAREN SEMICOLON
;

SwitchCaseList ::= (SwitchCaseList) CASE NUMBER COLON StatementList

OpenStatement ::= (OpenIf) IF LPAREN Condition RPAREN THEN Statement
            | (OpenIfElse) IF LPAREN Condition RPAREN THEN MatchedStatement ELSE OpenStatement
;

DesignatorStatement ::= (Assignment) Designator Assignop Expr
                    | (FuncCall) Designator LPAREN ActPars RPAREN
                    | (PostIncStmt) Designator PPLUS
                    | (PostDecStmt) Designator MMINUS
;

ActPars ::= (ActualParams) ActParList
        | (NoActualParams)
;

ActParList ::= (ActParams) ActParList COMMA Expr
            | (ActParam) Expr
;

Condition ::= (OrCondition) Condition OR CondTerm
        | (Condition) CondTerm
;

CondTerm ::= (AndCondTerm) CondTerm AND CondFact
        | (CondTerm) CondFact
;

CondFact ::= (CmpCondFact) Expr Relop Expr
    | (CondFact) Expr
;

Expr ::= (Expr) TermExpr
    | (NegExpr) MINUS TermExpr
    | (TerExpr) Condition QUESTION Expr COLON Expr
;

TermExpr ::= (TermExpr) TermExpr Addop Term
            (TermExpr) Term
;

Term ::= (MulTerm) Term Mulop Factor
    | (Term) Factor
;

Factor ::= (Var) DESIGNATOR
        | (FuncCall) DESIGNATOR LPAREN ActPars RPAREN
        | (NumConst) NUMBER
        | (CharConst) CHAR
        | (BoolConst) BOOL
        | (NewVar) NEW Type
        | (NewArray) NEW Type LPAREN Expr RPAREN
        | (ExprVar) LPAREN Expr RPAREN
;

Designator ::= (Designator) IDENT
            | (ObjectDesignator) Designator DOT IDENT
            | (ArrayDesignator) Designator LBRACKET Expr RBRACKET
;

Assignop ::= (Assignop) EQUALS ;

Relop ::= (Relop) CEQUALS
        | (Relop) CNEQUALS
        | (Relop) GREATER
        | (Relop) GEQUALS
        | (Relop) LESS
        | (Relop) LEQUALS
;

Addop ::= (Addop) PLUS
        | (Addop) MINUS
;

Mulop ::= (Mulop) MULTIPLY
        | (Mulop) DIVIDE
        | (Mulop) MODULO
;